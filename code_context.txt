### FILE: ./lib/devagent.rb
# frozen_string_literal: true

require "zeitwerk"
require_relative "devagent/version"

# Devagent is the primary namespace for the autonomous local agent gem.
module Devagent
  class Error < StandardError; end

  def self.loader
    @loader ||= Zeitwerk::Loader.for_gem.tap do |loader|
      loader.ignore("#{__dir__}/devagent/version.rb")
      loader.inflector.inflect("cli" => "CLI")
      loader.setup
    end
  end
end

Devagent.loader



### FILE: ./lib/devagent/auto.rb
# frozen_string_literal: true

require "tty-reader"
require_relative "planner"
require_relative "executor"

module Devagent
  # Auto exposes the interactive REPL that drives autonomous workflows.
  class Auto
    PROMPT = "devagent> "
    EXIT_COMMANDS = %w[exit quit].freeze

    def initialize(context, input: $stdin, output: $stdout)
      @context = context
      @input = input
      @output = output
      @executor = Executor.new(context)
      @max_iter = context.config.dig("auto", "max_iterations") || 3
      @require_green = context.config.dig("auto", "require_tests_green") != false
      @threshold = context.config.dig("auto", "confirmation_threshold") || 0.7

      # build index once, allow plugins to tune it
      context.plugins.each { |p| p.on_index(context) if p.respond_to?(:on_index) }
      context.index.build!
    end

    def repl
      greet

      reader = TTY::Reader.new
      loop do
        command = reader.read_line(PROMPT)
        break if command.nil? || exit_command?(command.strip)

        run(command.strip)
      end

      farewell
    end

    private

    attr_reader :context, :input, :output

    def greet
      output.puts("Devagent autonomous REPL. Type 'exit' to quit.")
    end

    def farewell
      output.puts("Goodbye!")
      :exited
    end

    def exit_command?(command)
      EXIT_COMMANDS.include?(command.downcase)
    end

    def run(task)
      plan = Planner.plan(ctx: @context, task: task)
      output.puts("Planning confidence: #{plan.confidence.round(2)}")
      output.puts("Executing…")
      iterate(task, plan)
    end

    def iterate(task, plan)
      (1..@max_iter).each do |i|
        output.puts("Iteration #{i}/#{@max_iter}")
        @executor.apply(plan.actions)

        # plugin post-processing (formatters, etc.)
        @context.plugins.each { |p| p.on_post_edit(@context, @executor.log.join("\n")) if p.respond_to?(:on_post_edit) }

        status = run_tests
        if status == :green
          @executor.finalize_success!("devagent: #{task}")
          output.puts("✅ Tests green. Changes committed.")
          return
        end

        output.puts("Tests red. Replanning…")
        feedback = gather_feedback
        plan = replan(task, feedback)
      end

      output.puts("❌ Could not get green within #{@max_iter} iterations. Check git diff and logs.")
    end

    def run_tests
      return :green if try_action_safe("rails:test")
      return :green if try_action_safe("gem:test")
      return :green if try_action_safe("react:test")
      :red
    end

    def try_action(name)
      @context.plugins.each do |p|
        if p.respond_to?(:on_action)
          res = p.on_action(@context, name, {})
          return res if res
        end
      end
      nil
    end

    def try_action_safe(name)
      @context.plugins.each do |p|
        next unless p.respond_to?(:on_action)
        begin
          ran = p.on_action(@context, name, {})
          return true if ran # on_action returns truthy when it actually ran a runner
        rescue => e
          @executor.log << "test action #{name} failed: #{e.message}"
          # continue to next plugin/runner
        end
      end
      false
    end

    def gather_feedback
      diff = `git -C #{@context.repo_path} diff --unified`.to_s
      rspec_log = File.exist?(File.join(@context.repo_path, "tmp", "rspec_failures.txt")) ? File.read(File.join(@context.repo_path, "tmp", "rspec_failures.txt")) : ""
      [diff, rspec_log].join("\n\n")
    end

    def replan(task, feedback)
      preface = <<~P
      #{Planner::SYSTEM}
      Previous attempt had failures. Use this feedback to fix:
      #{feedback}
      P
      raw = @context.llm.call(preface + "\nTask:\n" + task + "\nReturn JSON only.")
      json = JSON.parse(raw) rescue {"confidence" => 0.0, "actions" => []}
      Plan.new(json["actions"] || [], (json["confidence"] || 0.0).to_f)
    end
  end
end



### FILE: ./lib/devagent/cli.rb
# frozen_string_literal: true

require "thor"
require_relative "context"
require_relative "auto"
require_relative "diagnostics"

module Devagent
  # CLI exposes Thor commands for launching the agent and running diagnostics.
  class CLI < Thor
    def self.exit_on_failure?
      true
    end

    desc "start", "Start autonomous REPL (default)"
    def start
      ctx = Context.build(Dir.pwd)
      Auto.new(ctx, input: $stdin, output: $stdout).repl
    end

    desc "test", "Run diagnostics to verify configuration and Ollama connectivity"
    def test
      ctx = Context.build(Dir.pwd)
      diagnostics = Diagnostics.new(ctx, output: $stdout)
      success = diagnostics.run
      raise Thor::Error, "Diagnostics failed" unless success

      success
    end

    default_task :start
  end
end



### FILE: ./lib/devagent/context.rb
# frozen_string_literal: true

require "yaml"
require_relative "plugin_loader"
require_relative "index"
require_relative "memory"
require_relative "ollama"
require_relative "util"

module Devagent
  PluginContext = Struct.new(:repo_path, :config, :llm, :shell, :index, :memory, :plugins)

  # Context builds the dependencies (LLM, shell, index, plugins) for the agent.
  module Context
    DEFAULTS = {
      "model" => "codellama",
      "auto" => {
        "max_iterations" => 3,
        "dry_run" => false,
        "require_tests_green" => true,
        "confirmation_threshold" => 0.7,
        "allowlist" => ["app/**", "lib/**", "spec/**", "config/**", "db/**", "src/**"],
        "denylist" => ["node_modules/**", "log/**", "tmp/**", ".git/**", "dist/**", "build/**"]
      },
      "index" => { "threads" => 8, "globs" => ["**/*.{rb,erb,haml,slim,js,jsx,ts,tsx,rb,ru}"] }
    }.freeze

    def self.build(repo_path)
      config = config_for(repo_path)
      llm = build_llm(config)
      shell = build_shell(repo_path)
      index = Index.new(repo_path, config["index"])
      memory = Memory.new(repo_path)
      plugins = PluginLoader.load_plugins(
        PluginContext.new(repo_path, config, llm, shell, index, memory, [])
      )
      PluginContext.new(repo_path, config, llm, shell, index, memory, plugins)
    end

    def self.config_for(repo_path)
      cfg_path = File.join(repo_path, ".devagent.yml")
      DEFAULTS.merge(File.exist?(cfg_path) ? YAML.load_file(cfg_path) : {})
    end
    private_class_method :config_for

    def self.build_llm(config)
      lambda do |prompt, **opts|
        Ollama.query(prompt, model: config["model"], **opts)
      end
    end
    private_class_method :build_llm

    def self.build_shell(repo_path)
      lambda do |cmd, chdir: repo_path|
        Util.run!(cmd, chdir: chdir)
      end
    end
    private_class_method :build_shell
  end
end



### FILE: ./lib/devagent/diagnostics.rb
# frozen_string_literal: true

module Devagent
  # Diagnostics performs lightweight checks to validate configuration and dependencies.
  class Diagnostics
    def initialize(context, output: $stdout)
      @context = context
      @output = output
    end

    def run
      output.puts("Running Devagent diagnostics...")

      results = [
        check("configuration") { check_configuration },
        check("index build") { check_index },
        check("ollama connectivity") { check_ollama }
      ]

      success = results.all?
      output.puts(success ? "All checks passed." : "Some checks failed.")
      success
    end

    private

    attr_reader :context, :output

    def check(label)
      output.print(" - #{label}... ")
      message = yield
      output.puts("OK")
      output.puts("   #{message}") if message.is_a?(String) && !message.empty?
      true
    rescue StandardError => e
      output.puts("FAIL")
      output.puts("   #{e.message}")
      false
    end

    def check_configuration
      model = configured_model
      "model: #{model}, #{plugin_summary}"
    end

    def check_index
      index = context.index
      index.build!
      index.retrieve("diagnostic", limit: 1) # ensure retrieval executes without error
      "indexed files: #{index.document_count}"
    end

    def check_ollama
      response = context.llm.call("Respond with the single word READY.")
      text = response.to_s.strip
      raise "Unexpected response from Ollama: #{response.inspect}" unless text.downcase.include?("ready")

      "response: #{text}"
    end

    def configured_model
      model = (context.config || {})["model"].to_s
      raise "LLM model not configured. Set `model` in .devagent.yml." if model.empty?

      model
    end

    def plugin_summary
      names = Array(context.plugins).map { |plugin| plugin.name.to_s.split("::").last }.reject(&:empty?)
      names.empty? ? "no plugins detected" : "plugins: #{names.join(", ")}"
    end
  end
end



### FILE: ./lib/devagent/executor.rb
# frozen_string_literal: true

require "diffy"
require "fileutils"
require_relative "safety"
require_relative "util"

module Devagent
  # Executor applies planned actions, runs commands, and manages rollback/snapshots.
  # rubocop:disable Metrics/ClassLength
  class Executor
    attr_reader :log

    ACTION_HANDLERS = {
      "create_file" => :handle_create_file,
      "edit_file" => :handle_edit_file,
      "apply_patch" => :handle_apply_patch,
      "run_command" => :handle_run_command,
      "generate_tests" => :handle_generate_tests,
      "migrate" => :handle_migrate
    }.freeze

    def initialize(ctx)
      @ctx = ctx
      @repo = ctx.repo_path
      @safety = Safety.new(ctx)
      @dry_run = ctx.config.dig("auto", "dry_run") ? true : false
      @log = []
      @snapshot_ref = nil
    end

    def snapshot!
      return if @dry_run
      # Create a stash snapshot of current state without altering history
      system("git", "-C", @repo, "stash", "push", "-u", "-k", "-m", "devagent: pre-change snapshot")
      @snapshot_stash = `git -C #{@repo} stash list`.lines.find { |l| l.include?("devagent: pre-change snapshot") }&.split(":")&.first
    end

    def rollback!
      return if @dry_run
      # Discard our changes and restore previous working tree from stash
      system("git", "-C", @repo, "reset", "--hard")
      system("git", "-C", @repo, "stash", "apply", @snapshot_stash) if @snapshot_stash
    end

    def finalize_success!(message = "devagent: implement request")
      return if @dry_run
      # Drop the snapshot; commit only what DevAgent actually changed
      system("git", "-C", @repo, "stash", "drop", @snapshot_stash) if @snapshot_stash
      system("git", "-C", @repo, "add", "-A")
      system("git", "-C", @repo, "commit", "-m", message)
    end

    def apply(plan)
      actions = Array(plan.respond_to?(:actions) ? plan.actions : plan)
      snapshot!
      actions.each { |action| apply_action(action) }
    rescue StandardError => e
      @log << "ERROR: #{e.message}"
      rollback!
      raise
    end

    def run_tests!(command = "bundle exec rspec")
      run_command(command)
    end

    def apply_action(action)
      type = action.fetch("type")
      handler = ACTION_HANDLERS[type]
      return @log << "Unknown action: #{action.inspect}" unless handler

      public_send(handler, action)
    end

    def create_file(relative_path, content)
      guard_path!(relative_path)
      @log << "create_file #{relative_path}"
      return if @dry_run

      absolute = File.join(@repo, relative_path)
      FileUtils.mkdir_p(File.dirname(absolute))
      File.write(absolute, content)
    end

    def edit_file(relative_path, content, _whole_file)
      guard_path!(relative_path)
      raise "content required for edit" if content.nil?

      absolute = File.join(@repo, relative_path)
      original = File.exist?(absolute) ? File.read(absolute) : ""
      rendered_diff = Diffy::Diff.new(original, content, context: 3).to_s(:text)
      @log << "edit_file #{relative_path}"
      @log << rendered_diff unless rendered_diff.empty?
      return if @dry_run

      FileUtils.mkdir_p(File.dirname(absolute))
      File.write(absolute, content)
    end

    def apply_patch(patch)
      raise "patch required" if patch.to_s.strip.empty?

      @log << "apply_patch"
      return if @dry_run

      IO.popen(["git", "-C", @repo, "apply", "--reject", "--whitespace=fix", "-"], "w") do |io|
        io.write(patch)
      end
      raise "git apply failed" unless $CHILD_STATUS&.success?
    end

    def run_command(command)
      raise "command required" if command.to_s.strip.empty?

      @log << "run: #{command}"
      return command if @dry_run

      Util.run!(command, chdir: @repo)
    end

    def generate_tests(path)
      if should_generate_spec?(path)
        create_spec_from_source(path)
      else
        initialize_rspec_suite
      end
    end

    def guess_spec_path(source)
      return File.join("spec", "generated_spec.rb") unless source&.end_with?(".rb")

      relative = source.sub(%r{^app/}, "")
      File.join("spec", relative.sub(/\.rb$/, "_spec.rb"))
    end

    private

    def handle_create_file(action)
      create_file(action["path"], action["content"] || "")
    end

    def handle_edit_file(action)
      edit_file(action["path"], action["content"], action["whole_file"])
    end

    def handle_apply_patch(action)
      apply_patch(action["patch"])
    end

    def handle_run_command(action)
      run_command(action["command"])
    end

    def handle_generate_tests(action)
      generate_tests(action["path"])
    end

    def handle_migrate(_action)
      run_command("bundle exec rails db:migrate")
    end

    def should_generate_spec?(path)
      path && !path.empty? && File.exist?(File.join(@repo, path))
    end

    def create_spec_from_source(path)
      source_path = File.join(@repo, path)
      content = File.read(source_path)
      spec_prompt = "Write comprehensive RSpec for this file:\n\n#{content}"
      spec = @ctx.llm.call(spec_prompt)
      spec_path = guess_spec_path(path)
      @log << "generate_tests -> #{spec_path}"
      return if @dry_run

      absolute_spec = File.join(@repo, spec_path)
      FileUtils.mkdir_p(File.dirname(absolute_spec))
      File.write(absolute_spec, spec)
    end

    def initialize_rspec_suite
      @log << "generate_tests -> rspec --init"
      run_command("bundle exec rspec --init")
    end

    def guard_path!(relative_path)
      raise "path required" if relative_path.to_s.empty?
      raise "path not allowed: #{relative_path}" unless @safety.allowed?(relative_path)
    end

    def run_and_log_system(*cmd)
      system(*cmd)
    end
  end
  # rubocop:enable Metrics/ClassLength
end



### FILE: ./lib/devagent/index.rb
# frozen_string_literal: true

require "parallel"
require "set" # rubocop:disable Lint/RedundantRequireStatement -- to_set needs explicit require
require_relative "util"

module Devagent
  # Index builds a lightweight word-token index across repository files.
  class Index
    def initialize(repo_path, config)
      @repo = repo_path
      @cfg = config
      @docs = []
    end

    def build!
      @docs = Parallel.map(target_files, in_threads: threads) do |path|
        text = read_text(path)
        next if text.empty?

        relative_path = relative_path_for(path)
        { path: relative_path, text: text, tokens: tokenize(text) }
      end.compact
    end

    def document_count
      @docs.size
    end

    def retrieve(query, limit: 12)
      query_tokens = tokenize(query)

      scored = @docs.map do |doc|
        overlap = (doc[:tokens] & query_tokens).size
        [overlap, doc]
      end

      scored.sort_by { |score, _| -score }
            .take(limit)
            .map { |(_, doc)| format_snippet(doc) }
    end

    private

    def threads
      @cfg["threads"] || 4
    end

    def target_files
      Array(@cfg["globs"])
        .flat_map { |pattern| Dir.glob(File.join(@repo, pattern)) }
        .uniq
        .reject { |path| File.directory?(path) }
        .select { |path| Util.text_file?(path) }
    end

    def read_text(path)
      File.read(path, encoding: "UTF-8")
    rescue StandardError
      ""
    end

    def relative_path_for(path)
      prefix = @repo.end_with?("/") ? @repo : "#{@repo}/"
      path.sub(prefix, "")
    end

    def tokenize(source)
      source.downcase.scan(/[a-z0-9_]{2,}/).to_set
    end

    def format_snippet(doc)
      head = doc[:text][0, 1200]
      "#{doc[:path]}:\n#{head}"
    end
  end
end



### FILE: ./lib/devagent/memory.rb
# frozen_string_literal: true

require "json"

module Devagent
  # Memory persists lightweight key/value data alongside the repository.
  class Memory
    def initialize(repo_path)
      @path = File.join(repo_path, ".devagent.memory.json")
      @store = load_store
    end

    def get(key)
      @store[key]
    end

    def set(key, value)
      @store[key] = value
      persist!
    end

    def delete(key)
      removed = @store.delete(key)
      persist! if removed
      removed
    end

    def all
      @store.dup
    end

    def persist!
      File.write(@path, JSON.pretty_generate(@store))
    end

    private

    def load_store
      return {} unless File.exist?(@path)

      JSON.parse(File.read(@path))
    rescue JSON::ParserError
      {}
    end
  end
end



### FILE: ./lib/devagent/ollama.rb
# frozen_string_literal: true

require "json"
require "net/http"

module Devagent
  # Ollama wraps local HTTP calls to the Ollama inference server.
  class Ollama
    ENDPOINT = URI("http://172.29.128.1:11434/api/generate")

    def self.query(prompt, model:)
      response = perform_request(prompt, model)
      ensure_success!(response)
      parse_response(response.body)
    end

    def self.perform_request(prompt, model)
      request = Net::HTTP::Post.new(ENDPOINT, "Content-Type" => "application/json")
      request.body = { model: model, prompt: prompt, stream: false }.to_json

      Net::HTTP.start(ENDPOINT.hostname, ENDPOINT.port) do |http|
        http.read_timeout = 120
        http.request(request)
      end
    end
    private_class_method :perform_request

    def self.ensure_success!(response)
      return if response.is_a?(Net::HTTPSuccess)

      raise "Ollama request failed (#{response.code}): #{response.body}"
    end
    private_class_method :ensure_success!

    def self.parse_response(body)
      parsed = JSON.parse(body)
      parsed.fetch("response")
    rescue JSON::ParserError
      raise "Ollama returned invalid JSON"
    end
    private_class_method :parse_response
  end
end



### FILE: ./lib/devagent/planner.rb
# frozen_string_literal: true

require "json"
require "json-schema"

module Devagent
  Plan = Struct.new(:actions, :confidence)

  # Planner asks the LLM for an actionable plan and validates the response.
  class Planner
    ACTION_SCHEMA = {
      "type" => {
        "type" => "string",
        "enum" => %w[edit_file create_file apply_patch run_command generate_tests migrate]
      },
      "path" => { "type" => %w[string null] },
      "whole_file" => { "type" => %w[boolean null] },
      "content" => { "type" => %w[string null] },
      "patch" => { "type" => %w[string null] },
      "command" => { "type" => %w[string null] },
      "notes" => { "type" => %w[string null] }
    }.freeze

    PLAN_SCHEMA = {
      "type" => "object",
      "required" => %w[actions confidence],
      "properties" => {
        "confidence" => { "type" => "number", "minimum" => 0, "maximum" => 1 },
        "actions" => { "type" => "array", "items" => { "type" => "object", "properties" => ACTION_SCHEMA } }
      }
    }.freeze

    SYSTEM = <<~SYS
      You are a senior software engineer. Return ONLY valid JSON.
      JSON:
      {
        "confidence": 0.0-1.0,
        "actions": [
          {"type": "create_file", "path": "relative/path.rb", "content": "..."},
          {"type": "edit_file", "path": "app/models/user.rb", "whole_file": true, "content": "..."},
          {"type": "apply_patch", "path": "app/models/user.rb", "patch": "UNIFIED DIFF"},
          {"type": "generate_tests", "path": "app/models/user.rb"},
          {"type": "run_command", "command": "bundle exec rspec"},
          {"type": "migrate"}
        ]
      }
      Constraints:
      - Paths must be INSIDE the repository and relative.
      - Prefer unified diffs for small changes; use whole_file for large rewrites.
      - For Rails, ensure migrations are reversible; add RSpec when needed.
      - Keep plans minimal and safe.
    SYS

    DEFAULT_PLAN = Plan.new([], 0.0).freeze

    def self.plan(ctx:, task:)
      prompt = build_prompt(ctx, task)
      json = parse_plan(invoke_llm(ctx, prompt))
      actions = json.fetch("actions", [])
      confidence = json.fetch("confidence", 0.0).to_f
      Plan.new(actions, confidence)
    end

    def self.safe_retrieve(ctx, task)
      return "" unless ctx.respond_to?(:index) && ctx.index.respond_to?(:retrieve)

      Array(ctx.index.retrieve(task, limit: 12)).join("\n\n")
    rescue StandardError
      ""
    end
    private_class_method :safe_retrieve

    def self.invoke_llm(ctx, prompt)
      llm = ctx.llm
      return "" unless llm.respond_to?(:call)

      llm.call(prompt).to_s
    rescue StandardError
      ""
    end
    private_class_method :invoke_llm

    def self.parse_plan(raw)
      return { "actions" => [], "confidence" => 0.0 } if raw.to_s.strip.empty?

      json = JSON.parse(raw)
      JSON::Validator.validate!(PLAN_SCHEMA, json)
      json
    rescue JSON::ParserError, JSON::Schema::SchemaError, JSON::Schema::ValidationError
      { "actions" => [], "confidence" => 0.0 }
    end
    private_class_method :parse_plan

    def self.build_prompt(ctx, task)
      <<~PROMPT
        #{preface_text(ctx, task)}
        #{SYSTEM}

        Repository context (truncated):
        #{safe_retrieve(ctx, task)}

        Task from user:
        #{task}

        Return JSON only.
      PROMPT
    end
    private_class_method :build_prompt

    def self.preface_text(ctx, task)
      Array(ctx.plugins).filter_map do |plugin|
        next unless plugin.respond_to?(:on_prompt)

        plugin.on_prompt(ctx, task)
      end.join("\n")
    end
    private_class_method :preface_text
  end
end



### FILE: ./lib/devagent/plugin.rb
# frozen_string_literal: true

module Devagent
  # Plugin defines the optional API surface for auto-loaded extensions.
  module Plugin
    class << self
      def applies?(_repo_path)
        false
      end

      def priority
        0
      end

      def on_load(_ctx); end

      def on_index(_ctx); end

      def on_prompt(_ctx, _task)
        ""
      end

      def on_action(_ctx, _name, _args = {})
        nil
      end

      def on_post_edit(_ctx, _log); end

      def commands
        {}
      end
    end
  end
end



### FILE: ./lib/devagent/plugin_loader.rb
# frozen_string_literal: true

require_relative "plugin"

module Devagent
  # PluginLoader discovers built-in and user-provided plugins.
  class PluginLoader
    BUILT_INS = %w[rails react ruby_gem].freeze
    EXCLUDED_MODS = [Devagent, Devagent::Plugin].freeze

    def self.load_plugins(ctx)
      load_builtin_plugins
      require_paths(plugin_paths(ctx.repo_path))
      matching_plugins(ctx.repo_path)
        .sort_by { |mod| -(mod.respond_to?(:priority) ? mod.priority : 0) }
    end

    def self.load_builtin_plugins
      BUILT_INS.each do |name|
        require_relative "plugins/#{name}"
      rescue LoadError
        next
      end
    end

    def self.require_paths(paths)
      paths.each { |path| require path }
    end
    private_class_method :require_paths

    def self.plugin_paths(repo_path)
      repo_plugins = Dir.glob(File.join(repo_path, ".devagent/plugins/**/*.rb"))
      user_plugins = Dir.glob(File.expand_path("~/.devagent/plugins/**/*.rb"))
      repo_plugins + user_plugins
    end
    private_class_method :plugin_paths

    def self.matching_plugins(repo_path)
      ObjectSpace.each_object(Module).with_object([]) do |mod, matches|
        next unless plugin_candidate?(mod)
        next unless mod.applies?(repo_path)

        matches << mod
      end
    end
    private_class_method :matching_plugins

    def self.plugin_candidate?(mod)
      return false unless mod.name&.start_with?("Devagent::")
      return false if EXCLUDED_MODS.include?(mod)
      return false unless mod.respond_to?(:applies?)

      true
    end
    private_class_method :plugin_candidate?
  end
end



### FILE: ./lib/devagent/plugins/rails.rb
# frozen_string_literal: true

require_relative "../plugin"

module Devagent
  module Plugins
    # Rails plugin tunes prompts and helpers for Rails applications.
    module Rails
      extend Devagent::Plugin

      def self.applies?(repo)
        File.exist?(File.join(repo, "bin", "rails")) && File.exist?(File.join(repo, "config", "application.rb"))
      end

      def self.priority
        100
      end

      def self.on_index(ctx)
        ctx.index # (could add ignore rules here)
      end

      def self.on_prompt(_ctx, _task)
        <<~SYS
          You are a senior Ruby on Rails engineer.
          - Follow Rails MVC conventions and strong params.
          - Ensure migrations are reversible.
          - Generate/maintain RSpec tests under spec/.
          - Return unified diffs for small edits, or whole file content for replacements.
        SYS
      end

      def self.on_action(ctx, name, _args = {})
        case name
        when "rails:test"
          ctx.shell.call("bundle exec rspec --format documentation", chdir: ctx.repo_path)
        end
      end
    end
  end
end



### FILE: ./lib/devagent/plugins/react.rb
# frozen_string_literal: true

require "json"
require_relative "../plugin"

module Devagent
  module Plugins
    # React plugin configures prompt guidance and test execution for React apps.
    module React
      extend Devagent::Plugin

      def self.applies?(repo)
        pkg = File.join(repo, "package.json")
        return false unless File.exist?(pkg)

        json = begin
          JSON.parse(File.read(pkg))
        rescue StandardError
          {}
        end
        deps = (json["dependencies"] || {}).merge(json["devDependencies"] || {})
        deps.key?("react")
      end

      def self.priority
        90
      end

      def self.on_prompt(_ctx, _task)
        <<~SYS
          You are a senior React engineer.
          - Prefer functional components and hooks.
          - Write Jest/RTL tests for new logic.
          - Keep components small and typed when TS available.
        SYS
      end

      def self.on_action(ctx, name, _args = {})
        case name
        when "react:test"
          if File.exist?(File.join(ctx.repo_path, "yarn.lock"))
            ctx.shell.call("yarn test --watchAll=false", chdir: ctx.repo_path)
          else
            ctx.shell.call("npm test --silent --", chdir: ctx.repo_path)
          end
        end
      end
    end
  end
end



### FILE: ./lib/devagent/plugins/ruby_gem.rb
# frozen_string_literal: true

require_relative "../plugin"

module Devagent
  module Plugins
    # RubyGem plugin adds conventions for Ruby library projects.
    module RubyGem
      extend Devagent::Plugin

      def self.applies?(repo)
        Dir.glob(File.join(repo, "*.gemspec")).any?
      end

      def self.priority
        80
      end

      def self.on_prompt(_ctx, _task)
        <<~SYS
          You are a senior Ruby library author.
          - Maintain semantic versioning and update CHANGELOG.
          - Provide thorough RSpec with boundary tests.
        SYS
      end

      def self.on_action(ctx, name, _args = {})
        case name
        when "gem:test"
          repo = ctx.repo_path
          gemfile = File.join(repo, "Gemfile")
          rspec_ok = rspec_available?(repo)

          unless rspec_ok
            # If we can, add rspec and initialize the suite once.
            if File.exist?(gemfile)
              begin
                ctx.shell.call("bundle add rspec", chdir: repo)
                ctx.shell.call("bundle exec rspec --init", chdir: repo)
                rspec_ok = true
              rescue => e
                return nil # don't crash test step; another plugin may handle tests
              end
            else
              return nil
            end
          end

          ctx.shell.call("bundle exec rspec --format documentation", chdir: repo) if rspec_ok
        end
      end

      def self.rspec_available?(repo)
        begin
          out = `cd #{Shellwords.escape(repo)} && bundle exec rspec -v 2>&1`
          $?.success?
        rescue
          false
        end
      end
    end
  end
end



### FILE: ./lib/devagent/safety.rb
# frozen_string_literal: true

module Devagent
  # Safety guards agent actions against disallowed file targets.
  class Safety
    def initialize(ctx)
      @repo = ctx.repo_path
      @allow = ctx.config.dig("auto", "allowlist") || ["**/*"]
      @deny = ctx.config.dig("auto", "denylist") || []
    end

    def inside_repo?(relative_path)
      full = File.expand_path(File.join(@repo, relative_path))
      repo_root = File.expand_path(@repo)
      prefix = repo_root.end_with?(File::SEPARATOR) ? repo_root : "#{repo_root}#{File::SEPARATOR}"
      full.start_with?(prefix)
    end

    def allowed?(relative_path)
      return false unless inside_repo?(relative_path)

      full_path = File.join(@repo, relative_path)
      allowed = @allow.any? { |glob| File.fnmatch?(File.join(@repo, glob), full_path, File::FNM_PATHNAME | File::FNM_EXTGLOB) }
      denied = @deny.any? { |glob| File.fnmatch?(File.join(@repo, glob), full_path, File::FNM_PATHNAME | File::FNM_EXTGLOB) }
      allowed && !denied
    end
  end
end



### FILE: ./lib/devagent/util.rb
# frozen_string_literal: true

require "open3"

module Devagent
  # Util contains shared helper routines for shelling out and file checks.
  module Util
    module_function

    def self.run!(cmd, chdir: Dir.pwd)
      stdout, stderr, status = Open3.capture3(cmd, chdir: chdir)
      unless status.success?
        raise "Command failed (#{cmd}):\nSTDOUT: #{stdout}\nSTDERR: #{stderr}"
      end
      stdout
    end

    def run!(cmd, chdir:)
      stdout, stderr, status = Open3.capture3(cmd, chdir: chdir)
      raise "Command failed (#{cmd}): #{stderr}" unless status.success?

      stdout
    end

    def text_file?(path)
      data = begin
        File.binread(path, 512)
      rescue StandardError
        return false
      end

      (data.count("^ -~\t\r\n").to_f / [data.size, 1].max) < 0.1
    end
  end
end



### FILE: ./lib/devagent/version.rb
# frozen_string_literal: true

module Devagent
  VERSION = "0.1.0"
end



